# Trading Strategies Project Memory

## Key Rules
- **Always read MEMORY.md first** before starting work on any strategy.
- **Never suggest strategy code without backtest KPIs** — always run the backtest first. If given PineScript code, convert it to Python and run it through the Backtest Engine to get KPIs before presenting the strategy.
- **Warm up moving averages**: Fetch chart data going at least 2x as far back as the longest MA period before the strategy start date.
- **PineScript version**: Always use V6 or later when analysing or writing TradingView Pine Script code.
- **File naming**: When outputting a strategy filename, increment the number by one (or add it if missing). This number must also be reflected in the strategy title.
- **Data source**: Fetch data from Bitstamp API by default. If the user says numbers don't match TradingView, suggest exporting chart data directly from TradingView for an exact match. Explain how: on the TV chart, click the **Export chart data…** button (small download icon in the bottom-right of the chart pane), save the CSV, and place it in the project root.
- **Slippage: NOT SIMULATED** — we cannot simulate slippage because it requires super-granular tick/order-book data which is expensive to obtain and analyse. Always set slippage to 0 in the engine and mention this in every backtest result.
- **Backtest results must always show**: (1) which chart data was used and where it came from, (2) all strategy settings so the user can verify they match TV, (3) the slippage note (set to 0, not simulated).
- **KPI display rule — always show both profit lines and use percentages**:
  1. **Total P&L (incl. open)** — first line, matches TV's Overview "Total P&L" = net_profit + open_profit. This is what the user sees first in TV.
  2. **Net Profit (closed)** — second line, matches TV's Excel "Net Profit" = sum of closed trade PnLs only.
  3. **Always show % alongside $** for Net Profit and Max Drawdown — users compare across different account sizes, so absolute $ alone is not useful.
  4. Show Max Drawdown as both $ and %.
- **Integration tests before shipping**: Run ALL test strategies in `dev/strategies/` and compare results with their `.xlsx` (TV data). Each test strategy is a triplet: `.py` (backtest), `.pine` (PineScript), `.xlsx` (TV export). Trade count, PF, win rate, and per-trade PnLs must match. Only ship if all tests pass.
- **Start-date safeguard**: The user's TV CSV export may not go back to the beginning of the chart. The engine auto-adjusts `start_date` to the first available bar and prints a warning. To match KPIs, the PineScript strategy **and** the Python backtest must use the same start date. Always code PineScript strategies with a configurable start date input. When the engine adjusts the date, tell the user to set the same date in TV's strategy properties (Date Range → Start Date).

## PineScript Coding Standards
- **`active` parameter**: Always use Pine Script V6's `active` parameter on checkboxes and pulldowns with a "No" option, so all related controls disable in tandem with the main settings input control.
- **Tooltips**: Always add comprehensive tooltips to ALL commands and fields in the Settings Inputs tab. Every `input.*()` call must have a `tooltip=` argument explaining what the setting does.

## Backtesting Engine
- Structure:
  - `engine/` — business logic: `engine.py` (core + indicators), `data.py` (data loaders), `__init__.py` (re-exports)
  - `data/` — chart data: CSV files + `cache/` for Bitstamp API
  - `strategies/` — strategy scripts: `example_ema_cross.py` (reference example)
- Data: TV-exported CSV (`data/INDEX_BTCUSD, 1D.csv`) — exact same OHLC as TradingView
- Also supports Bitstamp API fetch (fallback)
- See [backtesting-notes.md](backtesting-notes.md) for TV matching details
- **Last bar is always dropped** (unfinished candle) in both data loaders
- All imports come from one place: `from engine import load_tv_export, BacktestConfig, ...`

## Engine Architecture
- `engine/engine.py` is **strategy-agnostic** — accepts any DataFrame with signal columns
- **Long-only (`run_backtest`):** requires `Open`, `High`, `Low`, `Close`, `long_entry`, `long_exit`
- **Long+Short (`run_backtest_long_short`):** also requires `short_entry`, `short_exit`
- Strategy signals are generated by separate functions in `strategies/` (e.g. `ema_cross_signals()`)
- To add a new strategy: create a file in `strategies/`, write a `*_signals(df)` function, then pass to `run_backtest(df, config)` or `run_backtest_long_short(df, config)`

## Short Selling Cash Model
- `run_backtest_long_short()` supports long+short positions (never simultaneously)
- Short PnL: `qty * (entry_price - exit_price) - entry_commission - exit_commission`
- Intrabar DD for shorts uses bar `High` (worst case for short = price spike up)
- At short exit, settle from `cash` (not mark-to-market `equity`): `cash = cash + gross_pnl - exit_commission`

## Reversal Logic (Long ↔ Short)
- TV's `strategy.entry("Short")` reverses: closes any open long AND opens a short on the same bar
- Engine supports this via reversal detection in `run_backtest_long_short()`:
  - If `pending_long_exit` AND `short_entry`, both queue → exit fills first, then entry fills at same bar's Open
  - If `pending_short_exit` AND `long_entry`, same treatment
- Strategy must set cross-signals: `short_entry` should also trigger `long_exit`, and `long_entry` should also trigger `short_exit`

## Net Profit & Open P&L
- `net_profit` = sum of **closed** trade PnLs (matches TV's "Net Profit")
- `open_profit` = unrealised P&L from any position still open at data end
- `final_equity` = `initial_capital + net_profit + open_profit`
- Open trades (exit_date=None) are included in the trades list but excluded from KPI stats

## Available Indicators (in engine/engine.py)
- `calc_ema(series, length)` — EMA matching `ta.ema()`
- `calc_smma(series, length)` — Smoothed MA / RMA matching `ta.rma()`
- `calc_wma(series, length)` — Weighted MA matching `ta.wma()`
- `calc_hma(series, length)` — Hull Moving Average
- `calc_ehma(series, length)` — Exponential Hull MA
- `calc_thma(series, length)` — Triple Hull MA
- `calc_gaussian(series, length, poles)` — Gaussian filter (cascaded EMAs, 1–4 poles)
- `detect_crossover(fast, slow)` / `detect_crossunder(fast, slow)` — signal detection
- `get_source(df, source)` — price source selector (close/open/high/low/hl2/hlc3/ohlc4)
- All indicators handle NaN-leading input (safe to chain/cascade)

## TradingView Matching Behavior
- EMA: standard formula, multiplier=2/(len+1), seed with SMA of first `len` bars
- Signals: crossover/crossunder detected on bar close
- Order fill: **next bar open** (calc_on_every_tick=false, fill_orders_on_standard_ohlc=true)
- **Sizing: commission-adjusted** → `trade_value = equity / (1 + commission_rate)`, `qty = trade_value / fill_price`. This ensures `trade_value + entry_commission = equity` (total outlay never exceeds equity), matching TV's internal behaviour.
- Commission: pct of trade value, applied on BOTH entry and exit
- **Margin: set to 0%** for long and short in TV to match engine (100% margin causes spurious margin-call mini-trades)
- **Slippage: set to 0** — slippage simulation is not possible without expensive tick-level data; always set to 0 in both the engine and TV for matching
- **Max Drawdown: intrabar methodology** matching TV's "Max equity drawdown (intrabar)":
  - Uses bar `Low` price for worst-case equity during open long positions (not just Close)
  - Peak equity only updates when **flat** (no open position) — unrealised mark-to-market highs do NOT update the peak
  - Max DD ($) and max DD (%) are tracked as **independent maximums** — they may occur at different trades
  - Ref: https://www.tradingview.com/support/solutions/43000681690
  - Required columns: `High` and `Low` (in addition to `Open`, `Close`)

## Multi-Timeframe (MTF) Rules
- **Fetch each timeframe separately** from Bitstamp (or TV export per TF)
- **NEVER allow look-ahead bias** when using a higher timeframe (HTF) as a filter/signal
- A higher TF bar (e.g. 1W) is **not closed yet** while trading on a lower TF (e.g. 1D)
  → The HTF value must only update once the HTF bar actually closes
  → On a daily chart using weekly data: the weekly value only changes on the weekly close bar (e.g. Sunday/Monday), NOT mid-week
- Implementation approach: forward-fill (`ffill`) the HTF indicator onto the LTF index, shifted by one HTF bar, so each LTF bar only sees the **last completed** HTF value
- Always verify: no LTF bar should reference an HTF bar whose close date is in the future relative to that LTF bar

## Reference Backtest: EMA Cross on INDEX:BTCUSD 1D
- Data: TradingView export `INDEX_BTCUSD, 1D.csv`
- **Long-only (EMA 9/21):** Net Profit $9,180 (917.95%), 60 trades, 33.33% win rate, PF 1.813, Max DD -$3,420 (-61.01%)
- **Long+Short (EMA 9/21 long + EMA 5/13 short, with reversals):** Net Profit $1,501 (150.11%), 155 trades, PF 1.167, Open P&L ~$513
- First trade: Entry 2018-01-06 @ $16,955.45
- **TV with 0% margin**: matches Python's trade counts and PnLs

## Strategies Built

<!-- Add your strategies here as you build and validate them. Use this format:

### 1. <Strategy Name> — ✅ TV MATCH CONFIRMED
- **File:** `strategies/<your_strategy_file>.py`
- **Chart:** INDEX:BTCUSD 1D (TV export)
- **Settings:** <list all strategy parameters>
- **Config:** $1,000 capital, 100% equity, 0.1% commission, 0 slippage, 0% margin
- **Results:** Net Profit $X (X%), N trades, X% win rate, PF X.XXX
- **Max DD (intrabar):** -$X (-X%)
- **Key implementation notes:**
  - <any PineScript quirks, formula details, etc.>
-->

## Tech Notes
- No pyarrow installed — use CSV for caching (not parquet)
- Python 3.10+, pandas, numpy, requests (see requirements.txt)
